@shorttitle(Overview)
@title(Internet-Tools Overview)

@section(1 AnchorNameStarted Getting Started)

If you just want to download things, you can use the function @link(simpleinternet.retrieve retrieve) of the unit simpleinternet.@br@br

You can also further @noAutoLink(process) the data with the function @link(simpleinternet.process process) of the same unit.

@section(1 AnchorNameXYZ Accessing the internet/downloading things)

The interface TInternetAccess for accessing the internet is defined in the unit internetaccess, and contains several abstract methods to get/post http-data (other internet services like ftp/smtp might be added in future versions). @br 

Inherited from TInternetAccess are TSynapseInternetAccess and TW32InternetAccess (in the units synapseinternetaccess and w32internetaccess) which provide wrappers around synapse and wininet.  So you can easily switch between the two libraries and choose the most appropriate (wininet integrates better with windows systems, because it does not require openssl, but synapse it platform independent).


@section(1 AnchorNameXYZABC Data processing)

There are several ways to actually process a downloaded html/xml-document.@br
It is implemented as a hierarchy of data processing classes, from a high level template language to a low level tokenizer, where each levels uses the things from the lower level.

@section(2 AnchorNameTemplate High-Level: Template processing)

The most powerful processing language is implemented by the THtmlTemplateParser-class in the unit extendedhtmlparser.@br

To create a template, you can take the document you want to @noAutoLink(process), remove all unimportant things and annotate the remaining things with template commands that read the relevant data into variables. 

@section(2 AnchorNamePXP High-Mid-Level: PXPath/Expression processing)

The PXPath expression language which used within the templates is implemented by the TPseudoXPathParser-class in the unit pseudoxpath.

It is an almost complete implementation of the XPath 2 standard syntax + some things I needed for the templates (e.g. objects and variable assignments).

@section(2 AnchorNameTree Mid-Level: Tree/DOM-like processing)

To @noAutoLink(process) a html file directly in fpc, without using another, interpreted language, you can use the class TTreeParser in the unit simplehtmltreeparser.@br

It creates a tree of TTreeElement-s from the  html document text (you know such trees from DOM, but this tree has nothing to do with do(o)m).

@section(2 AnchorNameSimple Low-Level: Lexer/SAX-like interface)

At the lowest level you find the parseHTML function of the unit simplehtmlparser. @br 

It just splits a html document into tags and text elements and calls a callback function for each of the elements. @br@br

A similar function, parseXML, exists for xml data in the unit simplexmlparser (it treats the xml file as html file, but checks for things like  xml processing instructions). 

@section(1 AnchorNameOthers Other  things)

@unorderedList(
@item(The unit autoupdate contains the TAutoUpdater class which can look online for an available update for the current system architecture and then download/install it)
@item(The unit bbutils contains low-level functions, that are way below the simplehtmlparser and should actually be in the fpc rtl.  )
@item(The unit pastemplate implements a very simple template language for pascal units (such a template is used to generate bbutils) )
)


